# Get Artifacts as Job Outputs
A GitHub Action that retrieves artifacts from previous jobs in a workflow and makes them available as job outputs. This is particularly useful when you need to consolidate outputs from multiple matrix jobs or access data from previous workflow steps.


## Overview
This action helps you consolidate outputs from multiple jobs in a GitHub Actions workflow. It downloads artifacts from previous jobs, extracts their contents, and makes them available as outputs that can be referenced in subsequent steps.


## Features

- Automatically detects and downloads artifacts from dependent jobs

- Handles matrix jobs 

- Supports custom output file names

- Works with both successful and failed job runs

- Handles job reruns and multiple attempts


## Use Cases

- Consolidating test results from matrix jobs
- Gathering build artifacts for deployment
- Combining reports or metrics from parallel jobs
- Processing outputs from multiple workflow steps


## Usage

### Basic Example

```yaml
jobs:
  generate_results:
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix: 
        name: ["first", "second", "third"]
    steps:
      - uses: actions/checkout@v4
      - run: echo '{"result": "${{ matrix.name }} was successful"}' > outputs.json
      - name: Gather Results
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.name }}
          path: outputs.json

  gather_output:
    needs: [generate_results]
    runs-on: ubuntu-latest
    env:
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - id: previous_jobs
        uses: snapsheet/get-artifacts-as-outputs@0.1.1
        with:
          output_filename: outputs.json
        # ...when this job's outputs are accessed, it will have the following format:
        # {
        #   "first": { "summary": "first was successful" },
        #   "second": { "summary": "second was successful" },
        #   "third": { "summary": "third was successful" }
        # }

      - name: Generate Outputs
        id: markdown
        run: |
          echo '${{ steps.previous_jobs.outputs.generate_results }}' | jq -r 'keys[] as $k | "\($k) results: \(.[$k] | .summary)"'
        # (will print out the following)
        # first results: first was successful
        # second results: second was successful
        # third results: third was successful
```

### Dependencies

This project relies on having a GITHUB_TOKEN defined in the environment variables, with permission to read artifacts for this repository.

### Inputs

| Input | Description | Required | 
|-------|-------------|----------|
| `output_filename` | Name of the file that contains the job outputs | Yes |

### Outputs

A JSON object, where each key-value pair has a key corresponding to the job name, and value representing the content of the file found in the artifact(s), read as strings.

#### Example
```json
{
  "Some Job (1)": "{\"summary\": \"it was a success\" }",
  "Some Job (2)": "{\"summary\": \"somewhat of a success\" }",
  "Some Job (3)": "{\"summary\": \"total failure\" }"
}
```

## How It Works
1. The action identifies all jobs that the current job depends on (specified in `needs`)
2. For each dependent job:
   - Retrieves artifacts generated by that job
   - Downloads and extracts the artifact contents
   - Reads the specified output file
   - Makes the contents available as a job output with the same name as the dependent job

### Development

```bash
# Install dependencies
npm install

# Build the project
npm run build

# The project uses Jest for testing and maintains 100% line coverage (except for index.ts). Run tests with:
npm test

# To create a distribution branch for testing: 
# This creates a new branch named `dist/<current-branch-name>` with the compiled code that can be tagged for releases.
npm run dist-branch
```



### Project Structure
- `src/` - Source code
- `__tests__/` - Test files and fixtures
- `dist/` - Compiled output (generated)


## License

MIT License - see LICENSE file for details.


## Contributing

1. Fork the repository
2. Create a feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request
6. @snapsheet will review and merge your changes


## References
For more examples, see the test workflow in `__tests__/fixtures/workflow.yml`.
